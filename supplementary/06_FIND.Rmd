---
csl: D:/HiCcompare/styles.ref/bioinformatics.csl
bibliography: D:/HiCcompare/3D_DNA-references.bib
output:
  pdf_document:
    toc: no
  html_document:
    df_print: paged
    toc: no
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# Set up the environment
library(knitr)
opts_chunk$set(cache.path='cache/', fig.path='img/', cache=T, tidy=T, fig.keep='high', echo=F, dpi=100, warnings=F, message=F, comment=NA, warning=F, results='as.is', fig.width = 10, fig.height = 4) #out.width=700, 
library(pander)
panderOptions('table.split.table', Inf)
set.seed(1)
library(dplyr)
options(stringsAsFactors = FALSE)
```

\pagenumbering{gobble}

# 6 Comparison with `FIND`

## GM12878 vs. K562 comparison

Here we repeat the comparison of GM12878 and K562 presented in the FIND paper [@Djekidel:2018aa] using HiCcompare. First we calculated the maximum resolution of each dataset using `Juicer`. Supplemental Table 6.1 lists the maximum resolution of each of the datasets from the analysis. We then plotted the differential interactions detected by HiCcompare and FIND on a single MD plot displayed in Supplemental Fig. 6.1 for chromosome 1 at 1MB resolution. The interactions detected by HiCcompare tended to have larger fold change differences and larger average expression values than those detected by FIND (Supplemental Fig. 6.1 & Supplemental Table 6.3). Additionally FIND detected a much larger number of interactions than HiCcompare at 5KB resolution (Supplemental Table 6.2). However, we believe many of the interactions detected by FIND at 5KB resolution are not very trustworthy due to the sparsity of the data at 5KB resolution and the fact that the maximum resolutions calculated by `Juicer` are much coarser than 5KB. The mean non-zero IF for the GM12878 R1 file was 1.692 and the mean non-zero IF for the GM12878 R2 file was 1.673, further casting doubt on the ability to make any meaningful inferences at this resolution. Additionally we found that FIND takes greater than 72 hours to run on data at resolutions between 100KB and 10KB even in parallel using 16 cores on our department's cluster while HiCcompare is able to complete an analysis in a matter of minutes.

**Supplemental Table 6.1. Maximum resolution for Hi-C data.** Maximum resolution for each dataset used in the GM12878 vs K562 comparison as calculated by the `calculate_map_resolution.sh` script from `Juicer`. 

| Data Name  | GEO Sample  | Maximum Resolution |
|------------|-------------|--------------------|
| K562 R1    | GSM15551620 | 38.6 KB            |
| K562 R2    | GSM1551623  | 38.7 KB            |
| GM12878 R1 | GSM1551574  | 8.7 KB             |
| GM12878 R2 | GSM1551575  | 8.4 KB             |


\break

**Supplemental Figure 6.1. Comparison of HiCcompare detected regions and FIND detected regions for GM12878 vs K562.** Intereactions detected by HiCcompare are shown in red, interactions detected by FIND are shown in yellow. Data shown after HiCcompare's loess normalization. VC Square root normalized data was used for the FIND analysis and the raw data was input into the HiCcompare analysis. Significant interactions detected by FIND tend to have small fold changes while differences detected by HiCcompare have much larger fold changes. Chr 1 of GM12878 vs. K562 at 1MB resolution. 

```{r, fig.height=5, fig.width=6}
library(dplyr)
library(data.table)
library(HiCcompare)
load(file = 'data/1mb_FIND_results.RDA')
load(file = 'data/1mb_results.RDA')

combine.MD <- function(hiccompare, find) {
  # par(mfrow = c(1,2))
  M <- hiccompare$adj.M
  D <- hiccompare$D
  new.table <- left_join(hiccompare, find, by = c('start1' = 'region1', 'start2' = 'region2'))
  smoothScatter(D, M, xlab = 'Distance', ylab = 'M', main = 'HiCcompare vs FIND')
  hiccompare.sig <- which(new.table$p.adj < 0.05)
  find.sig <- which(new.table$detected == 1)
  points(D[hiccompare.sig], M[hiccompare.sig], col = 'red', pch = 20)
  points(D[find.sig], M[find.sig], col = 'yellow', pch = 20)
  
  # M.adj <- new.table$adj.M
  # smoothScatter(D, M.adj, xlab = 'Distance', ylab = 'M', main = 'After HiCcompare normalization')
  # points(D[hiccompare.sig], M.adj[hiccompare.sig], col = 'red', pch = 20)
  # points(D[find.sig], M.adj[find.sig], col = 'yellow', pch = 20)
  legend('bottomright', legend = c('HiCcompare', 'FIND'), fill = c('red', 'yellow'), bty = 'n', horiz = TRUE)
}

combine.MD(hic.table[[1]], find_pos[[1]])
```

\break

**Supplemental Table 6.2. Number of regions detected as significant by chromosome and resolution for the HiCcompare analysis of GM12878 vs K562.** The number of interactions detected start dropping off after 50KB due to the increasing sparsity of the data.


```{r}
load('data/num_sig_table.RDA')

knitr::kable(t_sig)
```

**Supplemental Table 6.3. Summary of M and A values for interaction detected by HiCcompare and FIND.** The Mean M values (log2 fold change) were split into two groups, those above 0 and those below 0. HiCcompare detected differences with larger fold changes than those detected by FIND. Additionally the average expression for the interactions detected by HiCcompare were larger than those detected by FIND.

```{r}
load('data/MA_table.RDA')

knitr::kable(MA.table)
```



## Comparison on data with a priori known differences

We performed a comparison of HiCcompare and FIND by adding in a priori known differencecs to GM12878 replicate data as described in the methods (section 4.7). This was performed at fold changes of 2, 3, and 5 on 1MB data for chr 18. 200 true differences were introduced at the specified fold changes between the two replicate datasets. Each dataset was then run through HiCcompare and FIND and standard performance classifiers were assessed. These results are listed in tables 6.4 - 6.6. Note that the total numbers differ between the HiCcompare and FIND columns due to the fact the HiCcompare ignores cells of the matrix with 0's while they are included in FIND. Classifiers are denoted by "TP" - true positives, "FP" - false positives, "TN" - true negatives, "FN" - false negatives, "TPR" - True Positive Rate, aka recall, or sensitivity $TP / (TP + FN)$, "SPC" - specificity, $TN / (FP + TN)$, "Accuracy" - $(TP + TN) / (TP + FP + TN + FN)$, "Precision" - $TP / (TP + FP)$, "FPR" - False Positive Rate, $FP / (FP + TN)$, "FNR" - False Negative Rate, $FN / (TP + FN)$, "FOR" - False omission rate, $FN / (FN + TN)$, "NPV" - Negative Predictive Value, $TN / (FN + TN)$, "MCC" - Matthews correlation coefficient, $\frac{TP \times TN - FP \times FN}{\sqrt{(TP + FP)(TP + FN)(TN + FP)(TN + FN)}}$.

**Supplemental Table 6.4. HiCcompare vs FIND on 2 fold change introduced differences.**

```{r}
load('data/find_v_hiccompare_tables.RDA')
knitr::kable(chr1.fc2$rates)
```


**Supplemental Table 6.5. HiCcompare vs FIND on 3 fold change introduced differences.**

```{r}
knitr::kable(chr1.fc3$rates)
```

\break

**Supplemental Table 6.6. HiCcompare vs FIND on 5 fold change introduced differences.**

```{r}
knitr::kable(chr1.fc5$rates)
```


## References
